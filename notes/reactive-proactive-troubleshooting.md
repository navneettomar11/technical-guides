# Reactive vs Proactive Troubleshooting: Mastering the Art of Performance

Between all languages, frameworks, containers, clouds and other critical building blocks of today's applications, figuring out what's causing a bottleneck in performance can often turn into a time consuming - and often frustrating - task. As long as you know where to look and have the right kind of visibility, finding and fixing problem doesn't have to be a painful process.

## When things go wrong
When your app is broken or slow, the first thing you're going to want to know is the impact and serverity of the issue. How many customers has it impacted? And for how long ? In order to rapidly triage and reduce mean time to resolution, look at:
- _Backend processes_: Response times, errors and transactions are essential elements here. You want quickly pinpoint if it was your code, backend server, or cloud service that caused an issue.
- _Frontend code_: With more and more code running on the client-side, you're going to want to see everything that happened from the first page load to the final click that completed a user's transaction.

In an ideal, you want to being in a reative situation. You want to have sense of confidence when your application is deployed - and the best way to do that is through pre-launch optimization.

## When things could go wrong
Before any launch, you should proactively monitor the core metrics above, run test monitors and set up advanced composite alerts that have context associated with their failures. All of this data should be feeding into a single analytics dashbard that can be used across developers, operations and product teams, so there's a shared understanding of performance across the organization.

This way, whether you find yourself in a reactive or proactive scenario, you're well equipped to resolve the issue quickly and go back to doing what you do best: writing new code, not troubleshooting it.
