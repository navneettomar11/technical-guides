Reactive programming is an asynchronous programming paradigm concerned with data streams and propagation of change. RXJS (Reactive Extension for Javascript) is a library for reactive programming using observables that makes it easier to compose asynchronous or call-back based code.

> Data Stream, also known as event stream processing, streaming data is the continous flow of data generated by various sources. By using stream processing technology, data streams can be processed, stored analyzed and acted upon as it's generated in real time.

# Introduction
RxJS is a library for composing asynchronous and event-based programs by using observable sequences(data streams). It provides one core type, the Observable, satellite types(Observer, Schedulers, Subjects) and operators inspired by Array@extras(map, filter, reduce, every,etc) to allow handling asynchronous event as collections.

> Think of RxJS as Lodash for events.

ReactiveX combines the `Observer pattern` with the `Iterator pattern` and `functional programming with collections` to fill the need for an ideal way of managinig sequences of events.

The essential concepts in RxJS which solve async event managment are:
- **Observable**: represents the idea of an invokable collection of future values or event.
- **Observer**: is a collection of callbacks that knows how to listen to values delivered by the Observable.
- **Subscription**: represents the execution of an Observable, is primarly useful for cancelling the execution.
- **Subject**: is the equilvalent to an EventEmitter, and the only way of multicasting a value or event multiple Observers.
- **Schedulers**: are centralized dispatchers to control concurrency, allowing us to coordinate when compution happens on e.g. `setTimeout` or `requestAnimationFrame` or others.

## Purity
What makes  RxJS powerful is it ability to produce values using pure functions. That means your code is less prone to errors.

Normally you would create an impure function, where other pieces of your code can mess up your state.
```javascript
let count = 0;
document.addEventListener('click', () => console.log(`Clicked ${++count} times`));
```
Using RxJS you isolate the state.
```javascript
import { fromEvent } from 'rxjs';
import { scan } from 'rxjs/operators';

fromEvent(document, 'click')
  .pipe(scan(count => count + 1, 0))
  .subscribe(count => console.log(`Clicked ${count} times`));
```
The scan operator works just like reduce for arrays. It takes a value which is exposed to a callback. The returned value of the callback will then become the next value exposed the next time the callback runs.

## Flow
RxJS has a whole range of operators that helps you control how the event flow through your observables.
This is how would allow at most one click per second, with plain Javascript:
```javascript
let count = 0;
let rate = 1000;
let lastClick = Date.now() - rate;
document.addEventListener('click', () => {
  if (Date.now() - lastClick >= rate) {
    console.log(`Clicked ${++count} times`);
    lastClick = Date.now();
  }
});
```

with RxJS
```javascript
import { fromEvent } from 'rxjs';
import { throttleTime, scan } from 'rxjs/operators';

fromEvent(document, 'click')
  .pipe(
    throttleTime(1000),
    scan(count => count + 1, 0)
  )
  .subscribe(count => console.log(`Clicked ${count} times`));
```

## Values
You can transform the values passed through your observables.

Here's how you can add the current mouse x position for every click, in plain Javascript:
```javascript
let count = 0;
const rate = 1000;
let lastClick = Date.now() - rate;
document.addEventListener('click', event => {
  if (Date.now() - lastClick >= rate) {
    count += event.clientX;
    console.log(count);
    lastClick = Date.now();
  }
});
```

With RxJS
```javascript
import { fromEvent } from 'rxjs';
import { throttleTime, map, scan } from 'rxjs/operators';

fromEvent(document, 'click')
  .pipe(
    throttleTime(1000),
    map(event => event.clientX),
    scan((count, clientX) => count + clientX, 0)
  )
  .subscribe(count => console.log(count));
```

# Observable
Observable are lazy Push collections of multiple values. They fill the missing spot in the following table:

| |Single|Multiple|
|-|------|--------|
|Pull| Function| Iterator|
|Push| Promise| Observable|

## Pull versus Push
Pull and Push are two different protocols that describe how a data Producer can communicate with a data Consumer.
What is Pull? In Pull systems, the Consumer determines when it receives data from the data Producer. The Producer itself is unaware of when the data will be delivered to the Consumer.
Every Javascript is a Pull system. The function is a Producer of data, and the code that calls the function is consuming it by "pulling" out a single return value from its call.
ES2015 introduced generator functions and iterators(function**), another type of Pull system. Code that calls `iterator.next()` is the Consumer "pulling" out multiple values from the iterator(the Producer).

| |PRODUCER|CONSUMER|
|-|--------|--------|
|Pull| Passive: produces data when requested| Active: decides when data is requested|
|Push: Active: produces data as its own pace.| Passive: reacts to received data|

What is Push? In Push systems, the Producer determines when to send data to the Consumer. The Consumer is unware of when it will receive that data.

Promise are the most common type of Push system in Javascript today. A Promise (the Producer) deliver a resolved value to registered callback(the Consumers), but unlike function,it is the Promise which is in change of determining precisely when that value is "pushed" to the callbacks.

RxJS introduces Oberservables, a new Push system for Javascript. An Observable is a Producer of multiple values, "pushing" then to Observers(Consumers)
- A Function is a lazily evaluated computation that synchronously return a single value on invocation.
- A generator is a lazily evaluated computation that synchronously returns zero to (petentially) infinite values on iteration.
- A Promise is a computation that may (or may not) eventually return a single value.
- An Observable is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it's invoked onwards.

## Observable as generalization of functions
Contrary to popular claims, Observables are not like EventEmitters nor are they like Promise for multiple values. Observables may act like EventEmitters in some cases, namely when they are multicasted using RxJS Subjects, but usually they don't act like EventEmitters.

> Observables are like function with zero arguments, but generalize those to allow multiple values.

Consider the following
```javascript
function foo() {
  console.log('Hello');
  return 42;
}

const x = foo.call(); // same as foo()
console.log(x);
const y = foo.call(); // same as foo()
console.log(y);
```
We expect to see as output
```bash
"Hello"
42
"Hello"
42
```
You can write the same behavior above, but with Observables:
```javascript
import { Observable } from 'rxjs';

const foo = new Observable(subscriber => {
  console.log('Hello');
  subscriber.next(42);
});

foo.subscribe(x => {
  console.log(x);
});
foo.subscribe(y => {
  console.log(y);
});
```
And the output is the same
```bash
"Hello"
42
"Hello"
42
```
This happens because both functions and Observables are lazy computations. If you don't call the function, the `console.log('Hello')` won't happen. Also with Observables, if you don't "call" it (with `subscribe`), the `console.log('Hello')` won't happen. Plus "calling" or "subscribing" is an isolated operation: two functions calls trigger two separate side effects, and two Observable subscribe trigger two seperate side effects. As opposed to EventEmitters which share the side effects and have eager execution regardless of the existence of subscribers, Observables have no shared execution and are lazy.

> Subscribing to an Observable is analogous to calling a Function

Some people claim that Observable are asynchronous. That is not true. If you surround a function call with logs, like this:
```javascript
console.log('before');
console.log(foo.call());
console.log('after');
```
You will see the output
```bash
"before"
"Hello"
42
"after"
```
After this is the same behavior with Observables:
```javascript
console.log('before');
foo.subscribe(x => {
  console.log(x);
});
console.log('after');
```
And the output is:
```bash
"before"
"Hello"
42
"after"
```

Which proves the subscription of foo was entirely synchronous, just like a function.

> Observables are able to deliver values either synchronously or asynchronously.

What is the difference between an Observable and a function? Observables can "return multiple values over times, something which functions cannot. You can't do this:
```javascript
function foo() {
  console.log('Hello');
  return 42;
  return 100; // dead code. will never happen
}
```
Function can only return one value. Observbles, however can do this:
```javascript
import { Observable } from 'rxjs';

const foo = new Observable(subscriber => {
  console.log('Hello');
  subscriber.next(42);
  subscriber.next(100); // "return" another value
  subscriber.next(200); // "return" yet another
});

console.log('before');
foo.subscribe(x => {
  console.log(x);
});
console.log('after');
```

With synchronous output
```bash
"before"
"Hello"
42
100
200
"after"
```

But you can also return value asynchronously:
```javascript
import { Observable } from 'rxjs';

const foo = new Observable(subscriber => {
  console.log('Hello');
  subscriber.next(42);
  subscriber.next(100);
  subscriber.next(200);
  setTimeout(() => {
    subscriber.next(300); // happens asynchronously
  }, 1000);
});

console.log('before');
foo.subscribe(x => {
  console.log(x);
});
console.log('after');
```
With output
```bash
"before"
"Hello"
42
100
200
"after"
300
```
### Conclusion
- `fun.call` means "give me one value synchronously"
- `observable,subscribr` means "give me any amount of values, either synchronusly and asynchronously.

## Anatomy of an Observable
Observables are created using `new Observable` or a creation operator, are subscribed to with an Observer, execute to deliver `next/error/complete` notification to the Observer, and their execution may be disposed. These four aspects are all encoded in an Observable instance, but some of these aspects are related to other types, like Observer and Subscription.
Core Observable concerns:
- Creating Observables
- Subscribing to Observables
- Executing the Observables
- Disposing Observables.

## Creating Observables
The `Observable` constructor an Observable to emit the string `hi` every second to a subscriber.

```javascript
import { Observable } from 'rxjs';

const observable = new Observable(function subscribe(subscriber) {
  const id = setInterval(() => {
    subscriber.next('hi')
  }, 1000);
});
```
> Observables can be created with new Observable. Most commonly, observables are created using creation function like, of, from, interval etc.

## Subscribing to Observables
The Observable `observable` in the example can be subscribed to, like this:

```javascript
observable.subscribe(x => console.log(x));
```

It is not coincidence that `observable.subscribe` and `subscribe` in `new Observable(function subscribe(subscriber){...})` have the same name in the library, they are different, but for pratical purpose you can consider them conceptually equal.

This show how `subscribe` calls are not shared among multiple Observers. When calling `observable.subscribe` with an Observer, the function subscribe in `new Obverable(function subscribe(subscriber) {...})` is run that given subscriber. Each call to `observable.subscribe` triggers its own independent setup for that given subscriber.

> Subscribing to an observable is like calling a function, providing callbacks where the data will be dilvered to.

This is drastically different to event handler APIs like `addEventListener / removeEventListener`. With `observable.subscribe`, the given Observer is not registered as a listener in the Observable. The Observable does not even maintain a list of attached Observers.

A `subscribe` call is simply a way to start an "Observable execution" and deliver values or events to an Observer of that execution.

## Executing Observables
The code inside `new Observable(function subscribe(subscriber){...})` represents an "Observable execution", a lazy computation that only happens for each Observer that subscribes. The execution produces multiple values over time, either synchronously or asynchronously.

There are three types of values an Observable Execution can deliver:
- "Next" notification: sends a value such as Number, a String, an Object, etc
- "Error" notification: sends a Javascript Error or exception.
- "Complete" notification does not send a value.

"Next" notifications are the most important and most common tyoe: they represent actual data being delivered to an subscriber. "Error" and "Complete" notifications may happen only once during the Observable Execution, and there can only be either one of them.

These constraints are expressed best in the so-called Observable Grammer or Contract as a regular expression.
```javascript
next*(error|complete)?
```
> In an Observable Execution, zero to infinite. Next notfication may be delivered. If either an Error or Complete notification is delivered, then nothing else can be delivered afterwards.

The following is an example of Observable execution that delivers three Next notfications, then completes:
```javascript
import { Observable } from 'rxjs';

const observable = new Observable(function subscribe(subscriber) {
  subscriber.next(1);
  subscriber.next(2);
  subscriber.next(3);
  subscriber.complete();
});
```

Observables strictly adhere to the Observable Contract, so the following code would not deliver the Next notfication 4:
```javascript
import { Observable } from 'rxjs';

const observable = new Observable(function subscribe(subscriber) {
  subscriber.next(1);
  subscriber.next(2);
  subscriber.next(3);
  subscriber.complete();
  subscriber.next(4); // Is not delivered because it would violate the contract
});
```
It is a good idea to wrap any code in `subscribe` with `try/catch` block that will deliver an Error notification if it catches an exception:
```javascript
import { Observable } from 'rxjs';

const observable = new Observable(function subscribe(subscriber) {
  try {
    subscriber.next(1);
    subscriber.next(2);
    subscriber.next(3);
    subscriber.complete();
  } catch (err) {
    subscriber.error(err); // delivers an error if it caught one
  }
});
```

## Disposing Observable Executions
Because Observable Executions may be infinite, and it's common for an Observer to want to abort execution in finite time, we need an API for canceling an execution. Since each execution is exclusive to one Observer only, once the Observer is done receiving values, it has to have a way to stop the execution, in order to avoid wasting computation power or memory resources.

When `observable.subscribe` is called, the Observer gets attached to the newly created Observable execution. This call also returns an object, the `Subscription`.
```javascript
const subscription = observable.subscribe(x => console.log(x));
```

The Subscription represents the ongoing execution, and has a minimal API which allows you to cancel that execution. With `subscription.unsubscribe()` you can cancel the ongoing execution.

```javascript
import { from } from 'rxjs';

const observable = from([10, 20, 30]);
const subscription = observable.subscribe(x => console.log(x));
// Later:
subscription.unsubscribe();
```

> When you subscribe, you get back a Subscription, which represents the ongoing execution. Just call unsubscribe() to cancel the execution

Each Observable must define how to dispose resources of that execution when we create the Observable using `create()`. You can do that by returning a custom `unsubscribe` function from within `function subscribe().`

For instance, this is how we clear an interval execution set with `setInterval`:
```javascript
const observable = new Observable(function subscribe(subscriber) {
  // Keep track of the interval resource
  const intervalId = setInterval(() => {
    subscriber.next('hi');
  }, 1000);

  // Provide a way of canceling and disposing the interval resource
  return function unsubscribe() {
    clearInterval(intervalId);
  };
});
```
Just like `observable.subscribe` resembles `new Observable(function subscribe(){...})`, the `unsubscriber` we return from `subscribe` is conceptually equal to `subscription.unsubscribe`. In fact, if we remove the ReactiveX types surrounding these concepts, we're left with rather straightforward Javascript.

```javascript
function subscribe(subscriber) {
  const intervalId = setInterval(() => {
    subscriber.next('hi');
  }, 1000);

  return function unsubscribe() {
    clearInterval(intervalId);
  };
}

const unsubscribe = subscribe({next: (x) => console.log(x)});

// Later:
unsubscribe(); // dispose the resources
```
# Observer
What is an Observer? An Observer is a consumer of values delivered by an Observable. Observers are simply a set of callbacks, one for each type of notification delivered by the Observable: next, error and complete. The following is an example of a typical Observer object:
```javascript
const observer = {
  next: x => console.log('Observer got a next value: ' + x),
  error: err => console.error('Observer got an error: ' + err),
  complete: () => console.log('Observer got a complete notification'),
};
```
To use the Observer, provide it to the `subscribe` of an Observable:
```javascript
observable.subscribe(observer);
```
> Observers are just objects with three callbacks, one for each type of notification that an Observable may deliver.

Observers in RxJS may also be partial. If you don't provide one of the callback's, the execution of the Observable will still happen normally, except some types of notifications will ignored, because they don't have a corresponding callback in the Observer.

The example below is an Observer without the `complete` callback:
```javascript
const observer = {
  next: x => console.log('Observer got a next value: ' + x),
  error: err => console.error('Observer got an error: ' + err),
};
```
When subscribing to an Observable, you may also just provide the callbacks as argument, without being attached to an Observer object, for instance like this:
```javascript
observable.subscribe(x => console.log('Observer got a next value: ' + x));
```
Internally in `observable.subscribe`, it will create an Observer object using the first callback argument as the `next` handler. All threee types of callbacks may provided as argumenets:
```javascript
observable.subscribe(
  x => console.log('Observer got a next value: ' + x),
  err => console.error('Observer got an error: ' + err),
  () => console.log('Observer got a complete notification')
);
```
# Operators
RxJS is mostly useful for its operators, even though the Observable is the foundation. Operators are the essential pieces that allow complex asynchronous code to be easily composed in a declarative manner.

## What are operators?
Operators are functions. There are two kinds of operators:
Pipeable Operators are the kind that can be piped to Observables using the syntax `observableInstance.pipe(operator())`. These include, filter(...), and mergeMap(...). When called they do not change the existing Observable instance. Instead, they return a new Observable, whose subscription logic is based on the first Observable.

> A Pipeable Operator is a function that takes an Observable as its input and returns another Observable. It is a pure operation: the previous Observable stays unmodified.

A Pipeable Operators is essentially a pure function which takes one Observable as its input and generates another Observable as output. Subscribing to the output Observable will also subscribe to the input Observable.

Creation Operators are the other kind of operator, which can be called as standlone functions to create a new Observable. For example `of(1,2,3)` creates an observable that will emit 1, 2, and 3, one right after another.

For example, the operator called `map` is analogous to the Array method of the same name. Just as `[1,2,3].map(x => x*x)` will yield `[1,4,9]`, the Observable create like this:
```javascript
import { of } from 'rxjs';
import { map } from 'rxjs/operators';

map(x => x * x)(of(1, 2, 3)).subscribe((v) => console.log(`value: ${v}`));

// Logs:
// value: 1 
// value: 4
// value: 9
```
will emit 1, 4, 9. Another useful operator is `first`:
```javascript
import { of } from 'rxjs';
import { first } from 'rxjs/operators';

first()(of(1, 2, 3)).subscribe((v) => console.log(`value: ${v}`));

// Logs:
// value: 1
```
Note that `map` logically must be constructed on the fly, since it must be given the mapping function to. By contrast `first` could be constant, but is nonetheless constructed on the fly. As a general practive, all operators are constructed, whether they need arguments or not.

## Piping
Pipeable operators are functions, so they could be used like ordinary functons: `op()(obs)` - but in practice, there tend to be many of them convolved together, and quickly become unreadable: `op4()(op3()(op2()(op1()(obs))))`. For that reason, Observables have a method called `.pipe()` that accomplishes the same thing while being much easier to read:
```javascript
obs.pipe(
  op1(),
  op2(),
  op3(),
  op3(),
)
```
## Creation Operators
What are creation operators? Distinct from pipeable operators, creation operators are functions that can be used to create on Observable with some common predefined behavior or by joining other Obseravables.

A typical example of a creation operator would be the `interval` function. It takes a number (not an Observable) as input argument and produces an Observable as output.
```javascript
import { interval } from 'rxjs';

const observable = interval(1000 /* number of milliseconds */);
```
## High-order Observables
Observables most commonly emit ordinary values like strings and numbers, but suprisingly often, it is necessary to handle Observables of Observables, so-called high-order Observables. For example, imagine you had an Observable emitting strings that were the URLs of files you wanted to see. The code might look like this:
```javascript
const fileObservable = urlObservable.pipe(
   map(url => http.get(url)),
);
```
`http.get()` returns an Observable(of string of string arrays probably) for each individual URL. Now you have an Observables of Observables, a higer-order Observable.

But how do you work with a higher-order Observable? Typically, by flattering: by(somehow) converting a high-order Observable into an ordinary Observable. For example:
```javascript
const fileObservable = urlObservable.pipe(
   map(url => http.get(url)),
   concatAll(),
);
```
The `concatAll()` operator subscribe to each "inner" Observable that come out of the "outer" Observable, and copies all the emitted values until that Observable completes, and goes on to the next one. All of the values are in that way concatenated. Other useful flattening operators(called join operators) are:
- `mergeAll()` - subscribe to each inner Observable as it arrives, then emit each value as it arrives.
- `switchAll()` - subscribe to the first inner Observable when it arrives, and emits each value as it arrives, but when the next inner Observable arrives, unsubscribes to the previous one and subscribe to the new one.
- `exhaust()` - subscribe to the first inner Observable when it arrives and emits each value as it arrives, discarding all newly arriving inner Observables until that first one completes, then waits for the next Inner Observable.

Just as many array library combine `map()` and `flat()`(or flatten) into a single `flatMap()`, there are mapping equivalents of all RxJS flattening operators `concatMap`, `mergeMap`, `switchMap`, and `exhaustMap`.

## Marble diagrams
To explain how operators work, textual description are often not enough. Many operators are related to time, they may for instance delay, sample, throttle or debounce value emissions in different ways. Diagrams are often a better tool for that _Marble Diagrams_ are visual representation of how operators work and include the input Observable(s), the operator and its parameter and the output Observable.

> In a marble diagram, time flows to the right and the diagram describes how values ("marbles") are emitted on the Observable execution.

Below you can see the anatomy of a marble diagram.

![Marble Diagram](https://rxjs-dev.firebaseapp.com/assets/images/guide/marble-diagram-anatomy.svg)

## Categories of operators
There are operators for different purposes, and they may be categorized as: creation , transformation, filtering, joining, mutlicasting, error handling, utility, etc.

|Creation|Join Creation| Transformation| Filtering|Join| Multicasting| Error handling| Utility| Conditional and Boolean| Mathematical and Aggregate|
|--------|-------------|---------------|----------|----|-------------|---------------|--------|------------------------|---------------------------|
|ajax|combineLatest|buffer|audit|combineAll|mutlicast|catchError|tap|defaultIfEmpty|count|
|bindCallback|concat|bufferCount|auditTime|concatAll|publish|retry|delay|every|max|
|bindNodeCallback|forkJoin|bufferTime|debounce|exhaust|publishBehavior|retryWhen|delayWhen|find|min|
|defer|merge|bufferToggle|debounceTime|mergeAll|publishLast||dematerialize|findIndex|reduce|
|empty|partition|bufferWhen|distinct|startWith|publishRelay||materialize|isEmpty||
|from|race|concatMap|distinctKey|withLastestFrom|share||observeOn|||
|fromEvent|zip|concatMapTo|distinctUntilChanged||||subscribeOn|||
|fromEventPattern||exhaust|distinctUnitlKeyChanged||||timeInterval|||
|generate||exhaustMap|elementAt||||timestamp|||
|interval||expand|filter||||timeout|||
|of||groupBy|first||||timeoutWith|||
|range||map|ignoreElements||||toArray|||
|throwError||mapTo|last|||||||
|timer||mergeMap|sample|||||||
|iif||mergeMapTo|sampleTime|||||||
|||mergeScan|single|||||||
|||pairwise|skip|||||||
|||partition|skipLast|||||||
|||pluck|skipUntil|||||||
|||scan|skipWhile|||||||
|||switchMap|take|||||||
|||switchMapTo|takeUntil|||||||
|||window|takeWhile|||||||
|||windowCount|throttle|||||||
|||windowTime|throttleTime|||||||
|||windowToggle||||||||
|||windowWhen||||||||

##  Creating custom operators
### Use the pipe() function to make new operators
If there is commonly used sequence of operators in you code, use the `pipe()` function to extract the sequence into a new operator. Even if a sequence into a new operator. Even if a sequence is not that common, braking it out into a single operator can improve readability.

For example, you could make a function that discarded odd values and double even values like this:
```javascript
import { pipe } from 'rxjs';
import { filter, map } from 'rxjs/operators';

function discardOddDoubleEven() {
  return pipe(
    filter(v => ! (v % 2)),
    map(v => v + v),
  );
}
```
The `pipe()` function analogous to, but no the same thing as, the `.pipe()` method on an Observable.

### Creating new operators from scratch
It is more complicated, but if yoh have to write an operator that cannot be made from combination of existing operators (a rare occurance), you can write an operator from scratch using the Observable constructor like this:
```javascript
import { Observable } from 'rxjs';

function delay(delayInMillis) {
  return (observable) => new Observable(observer => {
    // this function will called each time this
    // Observable is subscribed to.
    const allTimerIDs = new Set();
    const subscription = observable.subscribe({
      next(value) {
        const timerID = setTimeout(() => {
          observer.next(value);
          allTimerIDs.delete(timerID);
        }, delayInMillis);
        allTimerIDs.add(timerID);
      },
      error(err) {
        observer.error(err);
      },
      complete() {
        observer.complete();
      }
    });
    // the return value is the teardown function,
    // which will be invoked when the new
    // Observable is unsubscribed from.
    return () => {
      subscription.unsubscribe();
      allTimerIDs.forEach(timerID => {
        clearTimeout(timerID);
      });
    }
  });
}
```
Note that you must
1. implement all three Observer functions, next(), error(), and complete() when subscribing to the input Observable.
2. implement a "teardown" function that cleans up when the Observable completes (in this case by unsubscribing and clearing any pending timeouts).
3. return that teardown function from the function passed to the Observable constructor.

# Subscription
What is a Subscription? A Subscription is an object that represents a disposable resource, usually the execution of an Observable. A Subscription has one important method, `unsubscribe`, that takes no argument and just disposes the resource held by the subscription. 
```javascript
import { interval } from 'rxjs';

const observable = interval(1000);
const subscription = observable.subscribe(x => console.log(x));
// Later:
// This cancels the ongoing Observable execution which
// was started by calling subscribe with an Observer.
subscription.unsubscribe();
```
> A Subscription essentially just has an unsubscribe() function to release resources or cancel Observable executions.

Subscriptions can also be put together, so that a call to an `unsubscribe()` of one Subscription may unsubscribe multiple Subscriptions. You can do this by "adding" one subscription into another.

```javascript
import { interval } from 'rxjs';

const observable1 = interval(400);
const observable2 = interval(300);

const subscription = observable1.subscribe(x => console.log('first: ' + x));
const childSubscription = observable2.subscribe(x => console.log('second: ' + x));

subscription.add(childSubscription);

setTimeout(() => {
  // Unsubscribes BOTH subscription and childSubscription
  subscription.unsubscribe();
}, 1000);
```
When executed, we see in the console:

```bash
second: 0
first: 0
second: 1
first: 1
second: 2
```

Subscriptions also have a remove(otherSubscription) method, in order to undo the addition of a child Subscription.

# Subject
An RxJS Subject is a special type of Observable that allows values to be multicasted to many Observers. While plain Observables are unicast(each subscribed Observer own as independent execution of the Observables), Subject are multicast.

> A Subject is like an Observable, but can multicast to many Observers. Subject are like EventEmitters: they maintain a registry of many listeners.

Every Subject is an Observable. Given a Subject, you can `subscribe` to it, providing an Observer, which will start reveiving values normally. From the perspective of the Observer, it cannot tell whether the Observable execution is coming from a plain unicast Observble or a Subject.

Internally to the Subject, `subscribe` does not invoke a new execution that delivers values. It simply registers the given Observer in a  list of Observers, similarly to how `addListener` ususally works in other libraries and languages.

Every Subject is an Observer. It is an object with the methods `next(v)`, `error(e)`, and `complete()`. To feed a new value to the Subject, just call `next(theValue)` and it will be multicasted to the Observers registered to listen to the Subject.

In the example below, we have two Observers attached to a Subject, and we feed some values to the Subject:
```javascript
import { Subject } from 'rxjs';

const subject = new Subject<number>();

subject.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});
subject.subscribe({
  next: (v) => console.log(`observerB: ${v}`)
});

subject.next(1);
subject.next(2);

// Logs:
// observerA: 1
// observerB: 1
// observerA: 2
// observerB: 2
```
Since a Subject is an Observer, this also , means you may provide a Subject as the argument to the `subscribe` of any Observable, like the example below shows:
```javascript
import { Subject, from } from 'rxjs';

const subject = new Subject<number>();

subject.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});
subject.subscribe({
  next: (v) => console.log(`observerB: ${v}`)
});

const observable = from([1, 2, 3]);

observable.subscribe(subject); // You can subscribe providing a Subject

// Logs:
// observerA: 1
// observerB: 1
// observerA: 2
// observerB: 2
// observerA: 3
// observerB: 3
```

With the approach above, we essentially just converted a unicast Observable execution to multicast through the Subject. This demonstrates how Subject are the only way of making an Observable execution be shared to multiple Observers.

There are also a few specializations of the `Subject` type: `BehaviorSubject`, `ReplaySubject` and `AsyncSubject`.

## Multicasted Observables
A "multicasted Observable" passes notifications through a Subject which may have many subscribers, whereas a plain "unicast Observable" only sends notifications to a single Observer.

> A multicasted Observable uses a Subject under the hood to make multiple Observers see the same Observable execution.

Under the hood, this is how the `multicast` operator works. Observers subscribe to an underlying Subject and the Subject subscribes to the source Observable. The following example is similar to the previous example which used `observable.subscribe(subject)`.

```javascript
import { from, Subject } from 'rxjs';
import { multicast } from 'rxjs/operators';

const source = from([1, 2, 3]);
const subject = new Subject();
const multicasted = source.pipe(multicast(subject));

// These are, under the hood, `subject.subscribe({...})`:
multicasted.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});
multicasted.subscribe({
  next: (v) => console.log(`observerB: ${v}`)
});

// This is, under the hood, `source.subscribe(subject)`:
multicasted.connect();
```
`multicast` returns an Observable that looks like a normal Observable, but works like a Subject when it comes to subscribing. `multicast` returns a `ConnectableObservable` which is simply an Observable with the `connect()` method.

The `connect()` method is important to determine exactly when the shared Observable execution will start. Because `connect()` does `source.subscribe(subject)` under the hood. `connect()` returns a Subscription, which you can unsubscribe from in order to cancel the shared Observable execution.

### Reference counting
Calling `connect()` manually and handling the Subscription is often cumbersome. Usually, we want to automatically connect when the first Observer arrives, and automatically cancel the shared execution when the last Observer unsubscribes.

Consider the following example where subscriptions occur as outlined by this list:
1. First Observer subscribes to the multicasted Observable
2. The multicasted Observable is connected.
3. The `next` value 0 is delivered to the first Observer.
4. Second Observer subscribes to the multicasted Observable
5. The `next` value 1 is delivered to the first Observer.
6. The `next` value 1 is delivered to the second Observer.
7. First Observer unsubscribes from the multicasted Observable.
8. The `next` value 2 is delivered to the second Observer.
9. Second Observer unsubscribes from the multicasted Observable.
10. The connection to the multicasted Observable is unsubscribed.

To achieve that with explicit calls to `connect()`, we write the following code:
```javascript
import { interval, Subject } from 'rxjs';
import { multicast } from 'rxjs/operators';

const source = interval(500);
const subject = new Subject();
const multicasted = source.pipe(multicast(subject));
let subscription1, subscription2, subscriptionConnect;

subscription1 = multicasted.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});
// We should call `connect()` here, because the first
// subscriber to `multicasted` is interested in consuming values
subscriptionConnect = multicasted.connect();

setTimeout(() => {
  subscription2 = multicasted.subscribe({
    next: (v) => console.log(`observerB: ${v}`)
  });
}, 600);

setTimeout(() => {
  subscription1.unsubscribe();
}, 1200);

// We should unsubscribe the shared Observable execution here,
// because `multicasted` would have no more subscribers after this
setTimeout(() => {
  subscription2.unsubscribe();
  subscriptionConnect.unsubscribe(); // for the shared Observable execution
}, 2000);
```

If we wish to avoid explicit calls to `connect()`, we can use ConnctableObservable's `refCount()` method(reference counting), which returns an Observable that keeps track of how many subscribers it has. When the number of subscribers increases from 0 to 1, it will call `connect()` for us, which starts the shared execution. Only when the number of subscribers decreases from 1 to 0 will it be fully unsubscribed, stopping further execution.
> refCount makes the multicasted Observable automatically start executing when the first subscriber-arrives, and stop executing when the last subscriber leaves.

Below is an example:
```javascript
import { interval, Subject } from 'rxjs';
import { multicast, refCount } from 'rxjs/operators';

const source = interval(500);
const subject = new Subject();
const refCounted = source.pipe(multicast(subject), refCount());
let subscription1, subscription2;

// This calls `connect()`, because
// it is the first subscriber to `refCounted`
console.log('observerA subscribed');
subscription1 = refCounted.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});

setTimeout(() => {
  console.log('observerB subscribed');
  subscription2 = refCounted.subscribe({
    next: (v) => console.log(`observerB: ${v}`)
  });
}, 600);

setTimeout(() => {
  console.log('observerA unsubscribed');
  subscription1.unsubscribe();
}, 1200);

// This is when the shared Observable execution will stop, because
// `refCounted` would have no more subscribers after this
setTimeout(() => {
  console.log('observerB unsubscribed');
  subscription2.unsubscribe();
}, 2000);

// Logs
// observerA subscribed
// observerA: 0
// observerB subscribed
// observerA: 1
// observerB: 1
// observerA unsubscribed
// observerB: 2
// observerB unsubscribed
```
The `refCount()` method only exists on ConnectableObservable and it returns an `Observable`, not another ConnectableObservable.

## BehaviorSubject
One of the variants of Subject is the `BehaviorSubject`, which has a notion of "the current value" from `BehaviorSubject`.

> BehaviorSubjects are useful for representing "values over time". For instance, an event stream of birthdays is a Subject, but the stream of a person's age would be a BehaviorSubject.

In the following example, the BehaviorSubject is initialized with the value 0 which the first Observer receives when it subscribes. The second Observer receives the value 2 even though it subscribed after the value 2 was sent.
```javascript
import { BehaviorSubject } from 'rxjs';
const subject = new BehaviorSubject(0); // 0 is the initial value

subject.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});

subject.next(1);
subject.next(2);

subject.subscribe({
  next: (v) => console.log(`observerB: ${v}`)
});

subject.next(3);

// Logs
// observerA: 0
// observerA: 1
// observerA: 2
// observerB: 2
// observerA: 3
// observerB: 3
```

## ReplaySubject
A `ReplaySubjet` is similar to a `BehaviorSubject` in that it can send old values to new subscribers, but it can also record a part of the Observable execution.

> A ReplaySubject records multiple values from the Observable execution and replays them to new subscribers.

When creating a `ReplaySubject`, you can specify how many values to replay.
```javascript
import { ReplaySubject } from 'rxjs';
const subject = new ReplaySubject(3); // buffer 3 values for new subscribers

subject.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});

subject.next(1);
subject.next(2);
subject.next(3);
subject.next(4);

subject.subscribe({
  next: (v) => console.log(`observerB: ${v}`)
});

subject.next(5);

// Logs:
// observerA: 1
// observerA: 2
// observerA: 3
// observerA: 4
// observerB: 2
// observerB: 3
// observerB: 4
// observerA: 5
// observerB: 5
```

You can also specify a window time in milliseconds, besides of the buffer size, to determine how old the recorded values can be. In the following example we use a large buffer size of 100, but a window time parameter of just 500 milliseconds.
```javascript
import { ReplaySubject } from 'rxjs';
const subject = new ReplaySubject(100, 500 /* windowTime */);

subject.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});

let i = 1;
setInterval(() => subject.next(i++), 200);

setTimeout(() => {
  subject.subscribe({
    next: (v) => console.log(`observerB: ${v}`)
  });
}, 1000);

// Logs
// observerA: 1
// observerA: 2
// observerA: 3
// observerA: 4
// observerA: 5
// observerB: 3
// observerB: 4
// observerB: 5
// observerA: 6
// observerB: 6
// ...
```

## AsyncSubject
The AsyncSubject is a variant only the last value of the Observable execution is sent to its observers, and only when the execution completes.
```javascript
import { AsyncSubject } from 'rxjs';
const subject = new AsyncSubject();

subject.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});

subject.next(1);
subject.next(2);
subject.next(3);
subject.next(4);

subject.subscribe({
  next: (v) => console.log(`observerB: ${v}`)
});

subject.next(5);
subject.complete();

// Logs:
// observerA: 5
// observerB: 5
```
The AsyncSubject is similar to the last() operator, in that it waits for the complete notification in order to deliver a single value.

# Scheduler
A scheduler controls when a subscrition starts and when notifications are delivered. It consists of three components.
- A scheduler is a data structure. It known to store and queue task based on priority or other criteria.
- A Scheduler is an execution context. It denotes where and when the task is executed(e.g. immediately, or in another callback mechanism such as setTimeout or process.nextTickm or the animation frame).
- A Scheduler has a (virtual) clock. It provides a notion of "time" by a getter method `now()` on the scheduler. Task being scheduled on a particular scheduler will adhere only to the time denoted by that clock.

> A Scheduler lets you define in what execution context will an Observable deliver notifications to its Observer.

In the example below, we take the usual simple Observable that emits values `1,2,3` synchronously, and use the operator `observeOn` to specify the `async` scheduler for delivering those values.
```javascript
import { Observable, asyncScheduler } from 'rxjs';
import { observeOn } from 'rxjs/operators';

const observable = new Observable((observer) => {
  observer.next(1);
  observer.next(2);
  observer.next(3);
  observer.complete();
}).pipe(
  observeOn(asyncScheduler)
);

console.log('just before subscribe');
observable.subscribe({
  next(x) {
    console.log('got value ' + x)
  },
  error(err) {
    console.error('something wrong occurred: ' + err);
  },
  complete() {
     console.log('done');
  }
});
console.log('just after subscribe');
```
Which executes win the output:
```bash
just before subscribe
just after subscribe
got value 1
got value 2
got value 3
done
```


Source: [RxJS](https://rxjs-dev.firebaseapp.com/guide/overview)